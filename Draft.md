iOS Books:
1) Advanced Swift - https://www.objc.io/books/advanced-swift/
2) https://books.google.com.ua/books?id=flzyDwAAQBAJ&pg=PT44&hl=uk&source=gbs_toc_r&cad=3#v=onepage&q&f=false
3) https://www.iosiqa.com/p/collection-of-ebooks-and.html?m=1
4) https://iosinterviewguide.com/
5) https://digitalbunker.dev/new-book-ace-the-ios-interview/amp/
6) https://www.waynewbishop.com/
7) https://www.hackingwithswift.com/interview-questions
8) https://papiro-books.com/en/product/all/the-ios-interview-guide
9) https://app.gumroad.com/a/630830195
10) https://www.kobo.com/ww/en/ebook/1000-ios-swift-most-important-interview-questions-and-answers
11) https://developpaper.com/interview-book-for-senior-ios-manufacturers/
12) https://www.oreilly.com/library/view/100-questions-and/9781484242735/
13) https://gist.github.com/nemissm/d1c50566be8ee1380685b7c6339da741

Public iOS interviews:
https://youtube.com/c/MadBrains


Topics:
-1) Загальні технічні питання
    1) what is heigh order functions, pure functions https://habr.com/ru/post/322806/
    2) як реалізувати rawValue в енама який має асосіетед вельюс
    Відповідь: потрібно самому реалізувати конструктор init?(rawValue: RawValue) і компютед пропертю var rawValue: RawValue
    3) різниця між лет і вар
    Відповідь: це ключові слова, які ставляться перед пропертьою чи змінною, щоб позначити чи може вона міняти своє знгачиння чи  вона є константою
    4) що таке функція
    Відповді: це блок коду який має своє імя, може мати аргументи і може мати тип повертання, функція є референс типом
    5) що таке код code signin
    Відповідь: це засіб безпеки, твій код має бути підписаний, код інших програмістів який ти використовуєш (3party framworks) має бути підписаний щоб уникнути використання небезпечного коду, аьбо коду який самомодифікується
    6) що таке абстрактний клас, чим він відрізняється від інтерфейса/протокола і як зробити в свіфт
    7) чому екстеншени не можуть мати сторед пропертіс
    Відповідь: на сторед проперті треба додаткова память, тому можна тільки функції або компютед проперті, які не потребують памяті додаткової
    8) Що таке opaque type https://habr.com/ru/company/otus/blog/542080/
    Відповідь: один "типів" типів: є абстрактинй тип (протоколи), конкретний(наші дефолтні типи), загальний(дженерік) і непрозорий. реалізовується за допомогою ключового слова some, працює він як реверснутий дженерік, тобто ми не ззвоні вказуєм який тип має бути, а тип визначається з середині і приховується на зовні, хоча повертається конкретний (це відрізнає його від протокола), дає нам можливість використовувати протокол з асосіейтед тайпом як тип повернення (без непрозорого типу у нас би була помилка компіляції, що такий тип мож використовувати тільки з дженеріком). Якщо в середені метода є умови, то може повертатися тільки один тип (з протоколом такого б не було, там можна або один або інший або третій, головне щоб вони реалізовували протокол)
    9) Що таке runloop
    Це такий безкінечний цикл призначений для обробки вхідних івентів, доторків, таймерів ітд. В кожного потока свій ранлуп, на основному потоці він зразу запущений, на інших треба самому запускати при потребі. Він вміє керувати потоком, а точніше будити його коли треба виконати якусь задачу і відправляти в сплячку коли задача виконана, є пару режимів роботи ранлупа: дефолтнийі івенттрекінг, комон (обєднує в собі попередні) 
    10) що таке defer
    Відповідь: блок коду що виконується в функції при виході зі скоупу, але після функції ретурн, якщо є пару функцій дефер, то вони виконуються знизу вверх
    11) Якщо у енама є ров велью то воно буде використовуватись при порівнянні енамів, але не використовується у свічі
    12) Чому всякі константи типу кольорів краще мати як енам ніж структуру
    Відповідь: бо структура нам позволить її створити і займе більше памяті
    13) Що таке mirror
    Відповідь: Reflection enables us to inspect, and work with, the members of a type — dynamically, at runtime. Завдяки мірору можна наприклад перетворити обєкти в словник, де ключаму будуть назви пропертів, а значеннями будуть значення пропертів, можна отримати доступ до приватних методів, я в свіфтюайі використовую для алертів (в мене є енум, який треба зробити ейдентіфаєбл і айдішку я визначаю через мірор, якшо в енума є асосіейтед вельюс)
    14) Що таке dependency injection
    Відповідь: це патерн дозволяє нам добитися слабкою звязаності, його часто потують з інверсіює залежностей, інверсія це просто принцип з соліда, а інджекшин це реалізація, позволяє нам покращити тестування, перевикористання, скейлінг і спапорт. Можилво реалізувати через конструктори, проперті, чи методи. Готові реалізації це тайфун свінджект нідл
    15) result builders https://habr.com/ru/company/otus/blog/555848/ https://www.hackingwithswift.com/swift/5.4/result-builders
    Відповідь: Построители результатов (result builders) в Swift позволяют получать результирующее значение из последовательности компонентов — выставленных друг за другом «строительных блоков». Описывающий объединение неких частей в окончательный результат. це один з стовпів в свіфтюай, дає наможливість писати код деклеративно і на виході отримувати одне значення як результат (у випадки з вюбілдер це буде TypelView де аргументи це перелік елементів шо ми додали, макс 10), дає нам можливість використовувати іф елс в свіфтюай, в загальному можна використовувати щоб зручніше писати констрейнти, або стрінги. Щоб самому створити резлтбілдер, треба використати пропертів врапер @resultbuilder а також реалізувати потрібні методи білдблок, білдайзе(щоб можна убло іф елс писати), білдарей, білдлуп ітд)
    16) датафлов в свіфтюай
    Відповідь: є проперті врапери для цього: 
        1)стейт(це для велью типів коли власником є конкретне вю)
        2)стейтобджект(це для референс типів, які мусять реалізовувати ObservableObject, коли власником є конкретне вю. Стейтобджекта не було в першій версії світюай і замість нього використовували обзерведобджект, але тоді появлявся баг, що при апдейті юая цей обєкт теж перестворювався)
        3)байндінг(щоб передавати стейт на інші вюшки і щоб вони могли його міняти)
        4)обзервердобджект (це для референс типів, які мусять реалізовувати ObservableObject, коли власником є не конкретне вю, а цей обєкт передають у в конретне вю звідкись)
        5)енвайронментобджект (можна добавляти до вю за допомогою модифікатора і тоді всі сабвюшки цього вю теж будуть мати до нього доступ)
        6)енвайронмент це похоже до енваронментобджекта, може шеритися між свюхами, але це ківелю пари які відповідальні за настройки (дісміс, опенурл ітд)
        7)паблішед(це з комбайна) якщо маємо клас який реалізовує ObservableObject, то щоб юай реагував на зміни пропертів цього класу, проперті мають мати паблішед проперті врапер
    Обновлення по байдінгу працює в дві сторони, міняємо значення якоїсь проперті то апдейтиться юай, міняємо це за допомогою юая то абдейтиться і пропертя

0) клас вс стуруктура, меморі менеджмент, респондер чейн - https://www.notion.so/moderator/CocoaHeads-c98598e39b4b48e29acaf9edfb3631f3
1) Memory management - https://habr.com/ru/post/592385/, https://habr.com/ru/company/hh/blog/546856/, https://habr.com/ru/company/otus/blog/666436/, https://medium.com/swift-india/when-self-should-be-weakify-35134c566728

Воперативній памяті віділяється місце для загрузки байткод програми для роботи а також стек і хіп
Стек: змінні які в стеці, до них дуже швидкий доступ і виділення памяті визначається на етапі компіляції. він використовується до статично виділення памяті, є структурою даних і організований по принципу Останній зайшов першивй вийшов, через це він дуже швидкий бо всі роботи ведуться з верхнім слоєм, є умова до дданих які зберігаються в стеці шо вони мають бути статичні, мати визначений розмір, кожен потік має свій власний стек, коли функція викликається то вона додається в стек, як тільки вона закінчилась, вона видаляється з стеку
Хіп: викоирстовується для динамічного виділення памяті, тут дані треба шукати як в бібліотеці по ссилці, вона повільніша за стек, бо тут є пошук даних, а в стеці всі наверху, тут дані можуть змінювати розмір, хіп є спільний для всіх потоків 
Управління памятю може бути ручне(сам виділяєш сам очищаєш) або автоматичне(система виділяє, система очещає, система рахує ссилки, від гарбідж колектора відрізняється тим що процес не іде з якимось інтервалом, а всьо прораховується на етапі компіляції, інструкції виділення і очищення вставляються зразу в байткод, воно помністю автономне, але не справляється з циклічними ссилками) і також є гарбідж колектор(пошук частин памяті що зайняті але не використовуються із позначанням їх щоб в якийсь момент очистити)

Value/Referance
Value(Структури, енами, прості типи, колекції, кортежі) кожна змінна велью типу має свою копію даних і операції з одною не впливають на інші, майже завжди зберігається в стеці, Referance(класи, замикання, функції, актори) є тільки один екземпляр, що передається по ссилці, операції впливають на оригінал і зберігаються в хіпі

Компілятор може пробувати запихати велютайпи в стек якщо їх розмір визначений і час життя можна передбачити на етапі генерації SIL (swift intermidiate language), але компілятор може і запихати їх в кучу якщо
1) було змішування велью і референс типів
2) при використанні inout
3) коли їх ловисть ескейпінг кложура ( бо дані в стеці тримаються до закінчення методу, а ескейпінг кложура може жити і після закінчення методу)
4) в залежності від розміра, там в діло вступає екзістенціальний контейнер (цей контейнер дає нам можливість мати масив де тип елементів протокол), вони розміщаються в хіпі а їх ссилки зберігаються в буфері контейнера.

Ручне керування
потрібно було самому проставляти alloc release retain dealloc, мінуси очевидні можна натупити і мати креші якшо звертатися до обєктів що вже вигружені з памяті, або мати витоки памяті якшо забувати робити реліз
Автоматичне керування
release retain проставляються на етапі компіляції (генерація SwiftIntermediateLanguage) а підрахунок ссилок іде в рантаймі, ці команди тепер неможна викликати. Несправляється він при ретейнсайклі, тому варто їх уникати. При рантаймі кожний обєкт в свіфт має 3 каунтера ссилок (строн вік і анноунд)
Завдання ссильної ссилки це тримати обєкт живим, саме вони можуть зробити ретейн сайкл
Завдання слабкої ссилки розбити цей ретейн скайкл, обєкт на який є тільки вік ссилка а нема стронг може бути вадалений з памяті, вона поверне ніл якшо обєкта по цій слабкій ссилці вже нема і креша не буде. Коли на обєкт появляються слабкі ссилки створюється сайд тейбл в якій зберігається каунтир слабких ссилок і слика на обєкт, обєкт має ссилки на таблицю
unowned це теж свого роду слабка ссилка але не створює сайд таблиць, буде креш як звернутися до обєкта який уже вмер, обєкт може бути видалений з памяті, якщо на нього тільки ановнед ссилки

Життєвий цикл обєкта
1) Live - нема сильних ссилок - Deinitin - якшо нема слабких чи ановнед - Dead
                                         - якщо є ановнед - Deinited - якщо нема слабких чи сайдтаблиць - Dead
                                                                     - якщо є слабкі і сайдтаблиці - Freed - якшо нема слабких - Dead

Ретейнсайкл
в нонескепінг кложурах можна не використовувати вік чи анноунд бо вони не живуть довше контекста
в ескейпінг кложурах теж не завжди обовязково бо ретейн сайкл там утвориться тільки на певний час, як тільки кложура виконається вона відпустить сильру ссилку і обєкт зможе удалитися
В кложурах де нема обєкта типу UIView.animate чи DispatchQueue.main.async ітд


    1) Copy on Write mechanisms - https://medium.com/@lucianoalmeida1/understanding-swift-copy-on-write-mechanisms-52ac31d68f2f, де епл його використовує? яку проблему вирішкє, як зробити самому, реалізований чи він з коробки для стандартних структур
    
    2) Як працює ARC, MRC, чи є арс в обджс, як працює сщотчик силок, хіпобджект, стейтмашина в обєкті, оптимізація свіфт по роботі счетчик ссилок  
    Відповідь: звичайно є арс в обджс
    3) різниця між weak i unowned
    4) для чого існує unowned і які його плюси
    5) різниця між стеком і хіпом, для чого потрібен стек
    6) чи може велью тип зберігатися в хіпі
    Відповідь: може якщо його захватує блок і він міняється в середині, є ще інші варіанти (вони в статті)
    7) яка різниця між вік і стронг
    8) для чого ми пишемо weak або unowned в кложурах
    Відповідь: строг по дефолту, вік можеть бути обєкти тільки референс типу, протокол може бути вік, якщо в нього є обмеження ені обджект
    9) скільки поміщається в стек
    10) mrc: retain, release, autorelease, autoreleasepool (життєвий цикл, коли і як використовувати в свіфті) метод дрейн
    11) сайд таблиці
    12) чому unowned швидше ніж weak, що таке unowned(safe)/unowned(unsafe)
    13) чи треба використовувати weak, unowned в GCD, UIView.animate
    14) Явний чи не явний захват ссилок в кложурах, для велью і для референс типів
    15) Табличка з питання ми по меморі менеджменту
    16) Як передавати функції в функції
    Відповідь: за допомогою кложур: функція є референс типом, вона може бути присвоєна до змінної і передана як аргумент
2) OOP
    1) Disadvantages of OOP
        Answer: Inheritance, отримуємо від батька всьо, і потрібне і не потрібне. Наслідуємся тільки від одного батька, нема множинного наслідування. Краще краще імплементовувати протоколи, але також не один великий, а багато малих (interface segregation)
    2) Як імітувати множинне наслідування
        Answer: До протокола його реалізацію можна добавити в екстеншені, тоді клас який реалізовує цей протокол отримає також цей функціонал. Підключивши 2 і більше таких протоколі ми імітуємо множинне наслідування (POP)
3) SOLID
    1) Приклади порушення солід в тому шо нам дає Епл
        Answer: ViewController і сінглтон(епл часто їх використовує, виконує те для чого його створили, але також і контролює кількість свої екземплярів) порушує single responsobility, сінглтон порушую опенклоузд принцип бо ми змушені його позначати як файнал щоб забрати можливість наслідування так як наслідники його вже не будуть сінглтонами, шаред завжди буде вказувати на батьківський клас, він порушує депенденсі інвершин якщо його використовувати влоб, без закриття протоколом і без інджекчення його в інший клас, також якщо його використовувати влоб то як цей який його використовує тестувати? як підмінити сінглтон, також поправилам тестування кожен тест має виконуватись на чистому енвароменті, а сінглтон буде отримувати на себе вплив попередніх тестів
4) Collections
    1) Типи колекції в свіфт
    2) Складність алгоритму пошуку по масиву
        Відповідь: O(n)
    3) Складність алгоритму сортування масиву 
        Відповідь: зазвичай O(nlogn), але може змінтится в залежності від данних і реалізації масиву
    4) Dictionary. Як він працює в середині
        Відповідь: ключом може бути будь що, що реалізовує Hashable. В середині є хеш функція для пошуку елементів і порівння
    5) як устроєні масиви?
        Відповідь: щоб були велю тайпом вони мають визначений розмір, (буфер в середині який є рефернс тайпом)?
    6) як веде себе масив (всі елементи одного розміру) коли типом його елементів є протокол, а протокол можуть реалізовувати різні за розміром типи
    7) Словник, як боротися з колізіями, для чого окрім хешбл ше треба ікватбл, якшо словник веде себе з елементами з однаковим хешом (можна навмисно       зробити однаковий хеш)
    8) Якщо елементи масиива мають бути однакового типу, то як він вирішує проблему з протоколами, var array: [SomeProtocol] = []
    Відповідь: Existential Container
    9) що таке Existential Container?
    10) Обєкт можна перетворити в хеш за допомогою хеш функції, а чи можна з хеш назад обєкт отримати?
    Відповідь: ні, неможливо, це порушення безпеки
    11) Хто кращий в ітерації і пошуку обєктів, сет чи аррей?
    Відповідь: якшо говоримо про контініус аррей, то там елементи викладені один за одинм за одним і вони всі одного розміру, тому проситм множення обєкт знаходиться дуже швидше
    12) Як тяжче вставити елемент, в кінець чи на початок масиву?
    13) Як працює конструктор репітінінг, чому кажуть що масиви є велью типом, а працює як референс
5) Architectures
    1) різниця між роутер і коордінатор
    2) яка різниця між вюмоделлю і презентером в MVVM vs MVP
    Відповідь: презентер має ссилку на Вю і Вю має ссилку на призентер (двонаправленість), а вюмодель не має (однонаправленість), у випадку з реактивним програмування вю підписується на вюмодель і реагує на зміни
6) Optionals
    1) Що це таке.
        Відповідь: це enum з двома кейсами none i some
7) App life cicle, viewcontroller life cicle
    1) що працює в бекграунді, що можна зробити в бекграунді
    2) Що буде з таймером якшо аппка перейшла в бекграунд
8) Багатопоточність
    Багатопочність це це принцип побудови програми коли декілька блоків можуть виконуватись одночасно (або псевдо одночасно -> одне ядро, світч контекст ітд) і не заважати друг другу.
    1) Що буде якшо викликати DispatchQueue.main.sync
    Відповідь: буде дедлок, синхронний блок буде очікуватичи поки звільниться головний потік (завершиться метод в якому він оголошений, але цей метод неможе завершитися, бо через то що блок синхронний ми змушені дочекатись кінця його виконання)
    2) 2 типи черг
    3)шо таке рейскондішин?
    Відповідь: гонка станів, це може статися коли декілька потоків працють з одною змінною в один час, вони читають і змінюють одночасно, тому ми не можемо бути впевнені в кінцевому результаті.
    4) Які варіанти цього уникнути? atomic, nonatomic в обджектів с, або локи в свіфті
    Відповідь: можливо можна використати барєри
    5) Інструменти для роботи з багатопоковістю, яка між ними різниця
    Відповідь: Pthreds (посікс потоки ),нстред, джісіді, оперейшн, async await actor (для зручності читання і писання коду, для уникнення колбекхела). Різниця в тому шо джісіді, оперейшн вже мають абстракції і користуються чергами
    6) Що таке барєр? https://medium.com/@nishant.kumbhare4/grand-central-dispatch-dispatchbarrier-488f75986477
    Відповідь: це ситуація очікування, щоб всі задачі до барєра виконалися перше ніж задачі після барєра почнуть виконуватися. Черга не буде виконувати наступні задачі поки не завершиться задача баєра. За допомогою барєра реалізовується readwritelock 
    Using concurrent can provide additional flexibility since you can decide if operations should be executed concurrently or "serially" with a .barrier flag, depending on behavior.
    7) Що буде якшо зробити sync на глобал чергу?
    Відповідь: нічо не буде, вона виконається але хз коли і так не варто робити, бо глобал черга є для системи, краще створити кастомун конкарент чергу
    8) що таке лок, чи семафор?
    Відповдь: семафор позволяє звертатися до ресурса з декілької потоків, локи тільки з одного, при створенні семафору з в конструктор ми передаєм кількість потоків з яким можна звертатися. Метод семафора wait блокує доступ до ресура, а метод signal розблоковує
    9) overcommit queue vs nonovercommit queue
    10) async await actor?
    Відповідь: вирішення проблеми колбекхелл
    11) Як добавляти задачі в чергу
    12) яка різниця між асинхронністю і багато потоковістю
    13) Яка різниця між чергою і потоком
    14) Яка різниця між DispatchQueue i OperationQueue
    Відповідь: там 3 важливі різниці, за домомогою OperationQueue можна вибудовувати залежності між задачами, можна керувати виконанням (зупиняти, продовжувати ітд) і ше якась одна
    15) Чи можна якось вручну керувати віділянням потоків, якшо так як виділити потік вручну, чи можна вручну поставити ліміт на кількість потоків які виділяються
    Відповіді: в оперейшн кю це макс конкарент оперейшнс, а також на семафорі мож це задати
    16) що таке інверсія пріорітетів, чому так відбувається?
    17) хочу скачати 10 картинок, а коли всі скачалась, зробити якусь дію, як це зробити в оперейшнкю
    18) якшо на серійній черзі зробити кенсл, яка операція закенсилться, та яка уже виконується чи та так яка ще не почалась
    відповідь: настпуні закенсаляться, в gcd тут операцію яка уже виконується закенсилити не можна
    19) що таке QOS
    Відповідь: Це інструмент для пріоритизації задач, їх є 6. UserInterective(взаємодія з користувачем на головному потоці, обновлення UI, анімаії), UserInitiated(це коли потрібно миттєвий результат, кліки клористувача, збереження в файл чи локальну базу даних), Default, Utility(не потребує миттєвого результату, балансує між проізводітєльностью і енергоефективністю, зазвичай такий тип задач це загрузка даних), Background(те що не видно для користувача, економить ресурси), Unspecified(квоси доступні з іос 8, тому для випадків роботи зі старим апі викоирстовуємо цей) Чим вищий пріорітет тим більша нагрузка на проц і батарею
    20) що таке потік
    Відповідь: A thread is nothing more than a context in which commands are executed. завдяки потокам нам доступна імітація паралельної роботи ( якщо в процесорі одне ядро, то воно фізично не може виконувати 2 задачі одночасно, тому час розділяється між задачами порціонно, тому складається враження що вони виконуються паралельно, така штука називаться content switch)
    21) що таке POSIX, pthreads
    Відповідь: це набір стандартів які описуються роботу ОС з програмою яка в ній запускається. В іос середовищі, є бібліотека pthresads написана на С, для роботи з потоками, використовувати в іос можна, але не рекомендується
    22) Що таке Thread, але вже на рівні іос https://habr.com/ru/post/572316/
    Відповідь: тред це обгорта над посікс потоком але вже на рівні мови, є наслідником НСОбджект, кожен потік має свій стек(для функцій і локальних змінних) та треддікшіонарі(локальне храниліще потока), потік може мати ранлуп, ранлуп може будити потік і погружати в сон, або conditional wait якшо роботи нема, без ранлупа система може відізвати потік
    23) Які проблеми можуть бути при роботі з потоками
    Відповідь: racecondition (змушує нас звертатися до механізмім синхронізації потоків), deadlock (якщо говорити в контексті синхронізації потоків, то два потоки стараються перехопити блокіровку один в одного і через це чекають друг друга безкінечно, якщо говорити в іншому контексті, то якщо зробити сінк на мейн потік то буде дедлок (чому?)), livelock (потоки перекидуються роботою, і ніхто її не робить), priority inversion (це помилка менеджмента потоків, це ситуація коли потоки з нижчим пріорітетом отримують доступ до заблокованої секції раніше ніж потоки з більшим пріорітетом, чому так стається?), starvation (потік безперервно старається отримати доступ до лока, але в нього це не получається)
    24) Які є механізми синхронізації потоків
    Відповідь: мютекси/локи барєр семафор
    1) рекурсів лок - разновидность базового mutex, которая позволяет потоку захватывать ресурс множество раз до тех пор, пока он не освободит его. Ядро операционной системы сохраняет след потока, который захватил ресурс и позволяет ему захватывать ресурс повторно. Рекурсивный мьютекс считает количество блокировок и разблокировок, таким образом ресурс будет захвачен до тех пор, пока их количество не станет равно друг другу. Чаще всего используется в рекурсивных функциях.
    2) кондітішн - Задача, закрытая condition, не начнет свое выполнение до тех пор, пока не получит сигнал из другого потока. Сигнал является неким триггером для condition, который говорит о том, что поток должен выйти из состояния ожидания.
    3) рідврайтлок - примитив синхронизации, который предоставляет потоку доступ к ресурсу на чтение, в это время закрывая возможность записи в ресурс из других потоков.
    4) спінлок(енергозатратна, весь час іде перевірка чи освободився ресурс), unfairlock(це блокування для зменшення кількості context switch, так як це дуже енергозатратно)
    25) Яка різниця між конкаренсі і паралелізмом
    Відповідь: це коли одна людина робить дві задачі переключаючись між ними, перекидаєте контест між двома задачами і потрошки просуваєтесь по кожній (switch context), а паралелізм це коли дві людини робить дві задачі одночасно. в Компютері за це відповідає кількість ядер процесора, якшо воно одне то відбувається конкаренсі, якшо більше то паралелізм
    26) 2 типи конкаренсі (shared memory i message passing)
    27) Що таке GCD
    Відповідь: це технологія, яка позволя виконувати задачі асинхронно, відповідає за менеджмент потоків, планує виконання задача на потоха в залежності від загруженості системи, вона оперує поняттями DispatchWorkItem (це клоужер з роботою яку треба виконати, може мати в собі QOS (відповдіає за пріорітет) ta DispatchWorkItemFlags, ці флаги відповідають за то як ця задача буде виконуватись наприклад барєр воркайтем можна відмінити методом cancel, але тільки до того моменту поки його не взяли в роботу, або дізнатися про його завершення через метод notify) та DispatchQueue (це обєкт який керує виконанням задач на головному чи фонових потоках, працює ідентично як структура даних Queue, тобто перший зайшов перший вийшов FIFO, може бути serial (виконує задачі одна за одною без всяких умови, може використовуватись як інструмент синхронізації в багатопотоковму програмуванні) aбо concurent (є 4 глобальні черги з різними пріорітетами, вона бере в роботу зараз стільки задач скільки може в залежності на скільки загружена система))
    28) різниця між sync i async
    Відповідь: Це способи черги взяти задачу в роботу, якшо синхронно то ми поміщаємо задачу в чергу і чекаєм коли вона виконається, якшо асинхронно то ми не чикаємо виконання, нам не важливо коли вона виконається, ми поклали задачу і пішли дальше. Якщо задача додається синхронно, ми будемо чекати її виконання, якшо в основній черзі то буде дедлок, якшо на конкарент черзі на практиці зазвичай дедлока не буде але затримка буде, бо ми змушені чекати, варто добре розрізняти черги потоки і сінк/асінк блоки, вони всі відповідають за різне, хоча ми зазвичай головну чергу називає головним потоком, бо вона серійна і потік там один.
    29) Як працює GCD
    Відповідь: маємо вокрайтем, який добавляється в чергу, коли черга бере цей воркайтем в роботу, вона просить у системи потік щоб виконати цей воркайтем. Ситема визначає на скільки вона загружена, на скільки загружений процесор, скільки інших задач вона має виконати і виділяє потік для виконання цього воркайтема. Тут працює патерн ThreadPool, тобто потоки не створюються в той момент коли вони потрібні, а уже є створені і система як видає по мірі необхідності, також вони можуть бути перевикористані, коли потік закінчив роботу він вертається в требапул.
    30) Що таке тредпул і скіки там може бути потоків (64?)
    31) Фічі GCD, Dispatchgroups, DispatchSemaphore, DispatchSources (слухаєм і реагуємо на системні обновлення), queue.concurentPerform (для циклів, вказуємо кількість ітерацій і система розпаралелює виконання в залежності від нагрузки)
    32) Що таке NSOperations
    Відповідь: складається з NSInvocationOperation i NSBlockOperation (це як воркайтеми в GCD), особливості операцій в тому що їх можна вручну запускати, так можна і через OprationQueue. Щоб вручну запустити є метод старт і його особливість в тому що він запускає виконання операціїї на каррент потоці. А операції які в черзі запускаються на отдєльном потоці. OperationQueue працює аналогічно до DispatchQueue, але може працювати напряму на потоках, або через GCD
    33) Чим Opeartions відрізняюються від GCD
    Відповідь: 1) можуть мати залежності, можна будувати залежності між операціями, наприклад якшо операція залежить від інших тасків, вона не виконається поки не завершаться всі від яких вона залежить, воно похоже на групи в GCD, але там один раз відстрелили коли всьо виконалось, а тут дерево залежностей так почутьчуть згортається 2) операціїї можна відміняти, навіть коли робота вже почалась (в GCD відміняти можна тільки до початку роботи) 3) за допомогою наслідування можна створити свою кастомну операцію щоб контролювати самому всі процеси. А контролювати всі процеся тажко, якшо операція синхронна то треба незабути перевизначити метод мейн і незабути синхронізувати доступи до даних операції щоб не зловити рейскондішн (навіть якшо операція синхронна до неї можна мати доступ з різних потоків). Але якшо операція асинхронна там все набагато складніше, треба перевизначити метод старт, перевизначити всі властивості isAsynchronous isExecuting, isFinished, isCanceld, а також підтримати KVO зміни статусу операціїї. Це все зробити ой як не просто, потрібно керувати станом операціїї і синхронізація доступу до даних
    34) шо таке глобальна черга (global queue)?
    35) Як виконати шось з затримкою?
    Відповідь: asyncAfter
9) UIKit
    1) Як працює аутолейаут
    Відповідь: Система лінійних рівнянь, яка вираховує все необхідне в залежності від обмежень які ми задали, враховуючи пріорітети які ми задали
    2) Що роблять проперті contenthaggingpriority i compresionresistanceprioprity?
    3) Задача, є кнопка яка не працює, як будеш шукати причину?
    4) Задача, є тейблвю який при скролі лагає, як будеш шукати причину? що таке блендінг, як виправити то шо він тормозить табличку
    Відповідь: корграфікс працює на cpu, а коранімейшн на gpu, перекидючи задачі можна збалансувати нагрузки. Якщо ти бачиш що фрейми падають від того що захльобується gpu, то замість того щоб на сіейлеєрках блендінг робити, ти можеш його відмалювати на корграфікс щоб знати нагрузку з gpu, що таке cpu i gpu?
    5) Що таке UIWindow
    6) яка ієархія аплікейшина? UIresponder
    7) як визначається вюшка яка відповідальна за дотик
    Відповідь: ранлуп ловить івент передає його на якусь вюшку самого низу, починається запуск хіттестів(який приймає івент і точку і вертає вю) на кожній сабвюшці чи точка попдає в неї, коли найшлася вюшка, на ній спрацюють методи тач беган, мув, енд якшо вони оверрайднуті, якшо є селектор, то спрацює він.
    8) 3 основні задачі UIView
    Відповідь: ієрархія, нажаття, відмальовка
    9) шо таке CALayer, яка їх ієархія, чи є в них проперті розміру і місця знаходження, які сабкласи сіалеєра для конкретнвих задач https://www.hackingwithswift.com/example-code/calayer/what-is-calayer
    10) різниця між фрейм і баундс, чи можливо відємний баундс? https://www.hackingwithswift.com/example-code/uikit/whats-the-difference-between-frame-and-bounds
    11) Які способи робити анімації
    12) Як зробити кастомний перехід між вюконтролерами
    13) Що таке CATransaction
    14) Що таке AffineTransformation
    15) Що таке експлісіті і інплісіті анімейшн
    16) Табличка з питаннями по респондер чейну!!!!
    17) методи датасурса і делегата таблиці і колекшенвюв, лейаути в колекшн вюв
    18) Які два способи верстки в юайкіті?
    Відповідь: фреймлейаут (це коли використовуємо фрейми), констрейнтлейауте(коли констрейнти)
10) Що подобається не подобається у Objc порівнюючи з Свіфт і навпаки.
Відповідь: метод діспатч шо вони різні, опшіонали, енами в свіфті більш розвинені, синтаксис блоків в обджс поганий, в обджектівсі потрібно прописувати купу атрибутів перед пропертьою. Є питання до проперті враперів, як їх тестувати, також в комбайні є методи з цифрами в назві, типу zip3 zip4, неподобається таке
11) Модифікатори доступа
    1) чим опен від пабліка відрізнається?
    2) для чого вони взагалі є
    Відповідь: Щоб скривати частини коду (функції чи проперті) від зовнішнього воздєствія
12) Наслідування
    1) шо таке final?
    2) чи можна оверрайднути статік метод?
    Відповідь не можна, тільки клас метод можна, в цьому різниця між статік і класс
    3) Що можна овверайднути в класі?
    Відповідь, можна методи, але не статік, а клас (питання вище), проперті, але оверрайд вже зробить з них компютед проперті, конструктори, сабскріпти
    4) Чи можна позначити ше шось окрім класа як final?
    Відповдь: можна його внутрішні методи, проперті, щоб захистити їх від перевизначення
13) Метод діспатч
Відповдіь: проезводітільность, 1) статична це прямий виклик в область памяті де знаходиться цей метод, 2)через віртуальні таблиці чи вітнис таблиці тобі ще треба знайти цей адрес і його викликати, тобто ше один додатковий крок, тому повільніше, 3) меседжсенд? 4) інлайн?
Табличка класи і структури
 1) Чи завжди велью типи використовують статичний метод діспатч
 2) яка різниця між діспатч методами? як вони працюють, різния тейбл діспатч від меседж діспатч, хто обробляє меседж діспатч під капотом
 3) як звязана діспач і наслідування
 4) як вплває final
 5) Шо таке whole modul optimization
 Вхол модул оптімізазайшін (проставлення final  всюди де можна, щоб максимально використовувати статичний методдіспач)
 6) Якщо у нас є масив типу батьківського, а в середині діти, то чий метод буде викликатися
 Відповді: це динамінчий метод діспатч, будуть методи дітей, а якшо масив тупу протокол, а в середині діти які його імплементують то там уже складніше
 7) якшо масив тупу протокол, а в середині діти які його імплементують, як методи будуть викликатися
15) Дженеріки
    Щоб мати можливість створити якусь функціональність не привязючись до конкретного типу, позволяє забрати багато дублікації коду, позволяє зробити таку штуку шо метод може примаймати два аргумента будь якого типу, але цей тип є однаковим для двох аргументів. Ми можемо використовувати протоколи для обмеження дженеріків
    1) що таке ключове слово where? яка різниця між "дженері:протоко" і "дженерік where"
    Відповідь: дає нам можливість уточняти асошіейтед тип
    2) Яка диспечирізація в дженеріка
    Відповідь статична, але є кейс коли буде динамічна, кожи дженерік в якомусь модулі і він незнає з якими типами буде працювати.
16) Конструктори  https://docs.swift.org/swift-book/LanguageGuide/Initialization.html
    1) Що таке конвіньєнс конструктор, що зними відбувається при наслідуванні
    Відповдь: це конструктор для зручності, він в середині мусить викликати інший ініціалізатор цього класу
    2) Приклад реквєд ініт
    Відповідь: ініт віз кодер в вюконтролері, або коли реалізовуємо протокол з конструктором в середині
    3) чому коли ми обявляємо свій конструктор нас заствляє реалізувати реквєрд конструктор
    Відповідь: клас наслідує конструктори свого батька до того моменту поки не обявляє свої конструктори
    4) Чому для класу свіфт не може згенерувати нам конструктор, як робить це зі структурою https://www.hackingwithswift.com/quick-start/understanding-swift/why-dont-swift-classes-have-a-memberwise-initializer
    5) три типи конструкторів
    Відповідь: рекваєрд, конвініент, дезігнейтед
    6) який ланцюг ініціалізації обєкта, чи може конвініанс викликати супер?
    Відповідь: конвініанс має виклакти в собі або інший конвініас, або дезігнейте, дезігнейтед має виклаккти супер якшо було наслідування
    7) як не втрати в структурі згенерований конструктор, якшо хоч додати кастомний?
    Відповідь: перенести кастомний в екстеншн
17) Ключові слова
    1) throws i retrhows https://www.hackingwithswift.com/example-code/language/how-to-use-the-rethrows-keyword
    2) fallthrough
18) Життєвий цикла додатка і вюконтролера
   1) де кращи підписуватись( додавати обсервери) на нотіфікейшини
   Відповідь: залежить від контексту, найкраще в віл апіар а відпосуватись в віл дісапіар, вроді зробили вже шо відписка відбувається автоматично
   2) для чого мож використати ресайн актів метод в аппделегаті
   Відповідь: для якихось дій коли юзер переходить до списку додатків, наприклад заблурити екран як в банківських додатках
19) Патерни
29) як працюють кокоапдос чи спм, феймворк бібліотека, динамічний статичний компільований, яка різниця між картажом і кокоаподс
Відповідь: кокоа подс невмів робити статичні бібліотеки
30) Class vs struct
    1) що таке inout
    Відповідь: аргументи в метод передаються лет(константа), а інаут дає нам можливість його змінювати
    2) що таке mutatingяк це працює під капотом, чи створює нову структуру чи міняє ту що є
    3) Табличка з питаннями по клас вс структура
    4) чи впливає розмір велью типу на місце де він буде розсташовуватись (в стеці чи в хіпі)
    5) Якщо кложура захватує валью тип, що відбувається?
    Втдповідь: неважливо як він його ловить, чи кепчур ліст чи ні, то це тип готується до створення своєї копії, яка буде створена якшо ми цей тип будемо модифікевати
    6) Коли краще використовувати класи а коли структури?
    Відповлі: структура має визначений розмір памятті, використовує статичний метлд діспатч, неможе зробити референс сайкл

31) Персістент
    1) Кешування, які є способи кешування
    2) які є опції для стореджу і персістенс
    Відповді: є колекції, юзердефолтс, кічейн, запис в фаіл, кордата чи реалм
    3) Як зберегти обєкт в юзердефолтс
    Відповідь: треба щоб він реалізовував протокол Codable, навіть енам з асосіетед велью можна таким способом зберегти
32) Дебагінг
    1) які інструменти є дебагінга
    Відповідь: інструменти, брейкпоінти, асерти, перкондішн, прінти, вю ієархія
    2) Які основні тулзи Instruments, для яких задач їх використовувати
    3) Як емолювати поганий інтернет (Network Link Conditioner)
33) git
    1) що таке git bisect, для чого він використовується
    відповідь: бінарний пошук по комітах щоб знайти той в якому баг
    2) Ситуація: я працював в гілці А, з неї створив гілку Б, як змерджити з мастер тільки зміни гілки Б?
34) Кложури
    1) що таке трейлінг кложура https://www.hackingwithswift.com/sixty/6/5/trailing-closure-syntax
    2) чи може функція мати кложуру як тип повертання
    Відповідь: може https://www.hackingwithswift.com/sixty/6/10/returning-closures-from-functions
    3) Що стається коли кепчер ліст ловить велью значення
    Відповді, створює копію яка не змінюється, а якшо захоплює клас, то він уже захоплює це по ссилці і там по іншому працює
    4) escaping, nonescaping, autoclosures(https://www.hackingwithswift.com/example-code/language/what-is-the-autoclosure-attribute), кепчурліст і як він працює, якими кложури є по дефолту(нонескейрінг, хоча спочатку були ескайпінг) чому так? чому поміняли?


Загальні питання
1) Чому я хочу змінити роботу
2) Що для мене компанія мрії
3) Мої сильні сторони
4) що зробив чим гордишся

1) складність алгоритму і її оцінка
2) бінарний пошук, яка його складність
4) мисиви хештаблиці сети
5) яка різниця вставка в початок і вставка в кінець масиву
6) шо таке хешвелью, колізії і хешфлудінг, хешбл протокол, який алгоритм хешування в свіфті
